#!/usr/bin/env perl

use strict;
use warnings;
use DateTime;
use DateTime::Duration;
use DateTime::Format::Human::Duration;
use File::Basename qw(fileparse);
use Fcntl ':flock';
use POE;
use POE::Component::IRC::Common qw(parse_user NORMAL DARK_GREEN DARK_BLUE ORANGE TEAL);
use POE::Component::IRC::Plugin::Connector;
use POE::Component::IRC::Plugin::FollowTail;
use POE::Component::IRC::State;
use FindBin;
use File::Spec::Functions qw(catfile);

# only run one instance of the IRC bot at a time
open my $self, '<', $0 or die "Couldn't open self: $!";
flock $self, LOCK_EX | LOCK_NB or die "This script is already running";

POE::Session->create(
    package_states => [
        (__PACKAGE__) => [qw(_start announce interrupt enqueue_torrent finish_torrent unrar_torrent irc_tail_input)],
    ],
);

$poe_kernel->run();

sub _start {
    my ($kernel, $session, $heap) = @_[KERNEL, SESSION, HEAP];

    $kernel->sig(INT => 'interrupt');
    
    my $irc_pass_path = catfile($FindBin::Bin, 'bouncer_pass.txt');
    my $irc_pass = qx/cat $irc_pass_path/;
    chomp $irc_pass;

    $heap->{irc} = POE::Component::IRC::State->spawn(
        nick         => 'freenode',
        password     => $irc_pass,
        server       => 'localhost',
        port         => 50445,
        debug        => 1,
        plugin_debug => 1,
    );

    # Uncomment this if you're not using a bouncer.
    # See "perldoc POE::Component:IRC::Plugin::AutoJoin"
    #
    #$heap->{irc}->plugin_add('AutoJoin', POE::Component::IRC::Plugin::AutoJoin->new(
    #    Channels => ['#channel1', '#channel2'],
    #));
        
    $heap->{irc}->plugin_add('Connector', POE::Component::IRC::Plugin::Connector->new());
    $heap->{irc}->plugin_add('FollowTail', POE::Component::IRC::Plugin::FollowTail->new(
        filename => '/tmp/torrentlog',
    ));

    $heap->{irc}->yield('connect');
}

sub interrupt {
    $_[HEAP]->{irc}->yield('shutdown');
}

sub irc_tail_input {
    my ($action, $args) = split /,/, $_[ARG1], 2;
    $_[KERNEL]->yield("${action}_torrent" => $args);
}

sub enqueue_torrent {
    my (undef, $hash, $bytes, undef, $file) = split /,/, $_[ARG0], 5;
    return if !defined $hash || !defined $bytes || !defined $file;

    my $name = fileparse($file);
    $name =~ s/\.torrent$//;
    my $user = getpwuid((stat $file)[4]);

    my $size = $bytes > 1024
        ? $bytes > 1_048_576
            ? $bytes > 1_073_741_824
                ? sprintf("%.2fGB", $bytes / 1_073_741_824)
                : sprintf("%.1fMB", $bytes / 1_048_576)
            : sprintf("%.0fKB", $bytes / 1024)
        : "$bytes bytes"
    ;
    
    my $msg = DARK_BLUE.'Enqueued: '.ORANGE.$name.NORMAL." ($size, by $user)";
    $poe_kernel->yield(announce => $msg);
}

sub finish_torrent {
    my ($finished, $hash, $bytes, $rars, $file) = split /,/, $_[ARG0], 5;
    return if !defined $finished || !defined $hash || !defined $bytes || !defined $rars || !defined $file;

    my $enqueued = (stat $file)[10];
    my $duration = _duration($enqueued, $finished);
    my $name = fileparse($file);
    $name =~ s/\.torrent$//;

    my $secs = $finished - $enqueued;
    my $bps = $bytes / $secs;
    my $rate = $bps > 1024
        ? $bps > 1_048_576
            ? sprintf("%.1fMB/s", $bps / 1_048_576)
            : sprintf("%.0fKB/s", $bps / 1024)
        : sprintf("%.0fB/s", $bps)
    ;

    my $msg = DARK_GREEN.'Finished: '.ORANGE.$name.NORMAL." in $duration ($rate)";
    my $files = $rars > 1 ? 'files' : 'file';
    $msg .= "; $rars $files to unrar" if $rars;
    $poe_kernel->yield(announce => $msg);
}

sub unrar_torrent {
    my ($start, $finish, $rars, $file) = split /,/, $_[ARG0], 5;
    return if !defined $start || !defined $finish || !defined $rars || !defined $file;

    my $duration = _duration($start, $finish);
    my $name = fileparse($file);
    $name =~ s/\.torrent$//;

    my $files = $rars > 1 ? 'files' : 'file';
    my $msg = TEAL.'Unrared: '.ORANGE.$name.NORMAL." in $duration ($rars $files)";
    $poe_kernel->yield(announce => $msg);
}

sub announce {
    my ($heap, $msg) = @_[HEAP, ARG0];
    my $irc = $heap->{irc};
    my $channels = $irc->channels();
    $irc->yield(notice => $_, $msg) for keys %$channels;
}

sub _duration {
    my ($start, $finish) = @_;

    my $enq_date = DateTime->from_epoch(epoch => $start);
    my $fin_date = DateTime->from_epoch(epoch => $finish);
    my $dur_obj = $fin_date - $enq_date;
    my $span = DateTime::Format::Human::Duration->new();
    return $span->format_duration($dur_obj);
}
